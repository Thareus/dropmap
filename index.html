<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DropMap</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.4.1/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.4.1/MarkerCluster.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.4.1/MarkerCluster.Default.css" />
    <style>
        :root {
            --primary-color: #0066cc;
            --primary-hover: #0052a3;
            --light-gray: #f0f0f0;
            --medium-gray: #e0e0e0;
            --dark-gray: #666;
            --border-color: #ccc;
            --bg-color: #fff;
            --text-color: #333;
            --section-padding: 20px;
            --border-radius: 6px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--light-gray);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px var(--section-padding);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        main {
            flex-grow: 1;
            padding: var(--section-padding);
            max-width: 1400px; /* Limit max width for large screens */
            width: 100%;
            margin: 0 auto;
            box-sizing: border-box;
        }

        section {
            background-color: var(--bg-color);
            padding: var(--section-padding);
            margin-bottom: var(--section-padding);
            border-radius: var(--border-radius);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        section h2, section h3 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        /* Upload Section */
        .drop-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            padding: 40px;
            text-align: center;
            background-color: #fdfdfd;
            transition: all 0.3s ease;
            margin-top: 15px;
        }
        .drop-area.active {
            border-color: var(--primary-color);
            background-color: #e6f2ff;
            box-shadow: 0 0 10px rgba(0, 102, 204, 0.3);
        }
        .drop-area h3 {
            margin-top: 0;
            color: var(--text-color);
            border-bottom: none;
        }
        .drop-area p {
            color: var(--dark-gray);
            margin-bottom: 20px;
        }

        /* Data Section */
        .file-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: var(--dark-gray);
        }
        .file-info-grid p {
            margin: 0;
            background-color: var(--light-gray);
            padding: 5px 10px;
            border-radius: 4px;
        }

        #sheet-selector-container {
            margin-bottom: 15px;
        }

        #table-container {
            max-height: 300px;
            overflow: auto;
            border: 1px solid var(--medium-gray);
            border-radius: var(--border-radius);
            margin-bottom: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid var(--medium-gray);
            padding: 10px 12px;
            text-align: left;
            font-size: 0.9em;
            white-space: nowrap;
        }
        th {
            background-color: var(--light-gray);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        tr:nth-child(even) td {
            background-color: #f9f9f9;
        }
        tr:hover td {
             background-color: #e6f2ff;
        }

        #preparation-status {
            margin-top: 15px;
            padding: 10px;
            background-color: var(--light-gray);
            border-radius: var(--border-radius);
            font-size: 0.9em;
            color: var(--dark-gray);
        }
        #preparation-status.success {
            font-size: large;
            font-weight: bold;
            border: 5px solid transparent;
            border-image: linear-gradient(to bottom right, #b827fc 0%, #2c90fc 25%, #b8fd33 50%, #fec837 75%, #fd1892 100%);
            border-image-slice: 1;
            animation: ease-in;
            border-radius: 10px;
            z-index: -1;
        }

        /* Map Section */
        #map-section-content {
            display: flex;
            flex-direction: column; /* Stack controls above map initially */
            gap: var(--section-padding);
        }

        #map-controls {
            background-color: var(--light-gray);
            padding: 15px;
            border-radius: var(--border-radius);
            overflow: auto; /* Allow scrolling if filters get too long */
            flex-shrink: 0;
        }
        #map-controls h3 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        #map-wrapper {
            flex-grow: 1;
            position: relative;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            min-height: 500px;
        }
        #map {
            height: 100%;
            width: 100%;
            border-radius: var(--border-radius);
        }

        #map-legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            z-index: 1000; /* Above map tiles */
            font-size: 0.85em;
        }
        #map-legend h4 {
            margin: 0 0 5px 0;
            font-size: 1em;
        }
        #hide-legend {
            float: right;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }
        .legend-color {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            border: 1px solid #aaa;
        }


        /* Filter Styling */
        #column-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive grid */
            gap: 15px;
        }

        .filter-fieldset {
            border: 1px solid var(--medium-gray);
            border-radius: var(--border-radius);
            padding: 10px 15px;
            margin: 0; /* Reset default fieldset margin */
        }
        .filter-fieldset legend {
            font-weight: bold;
            color: var(--primary-color);
            padding: 0 5px;
        }
        .filter-controls {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
        }
        .filter-controls label, .filter-controls span {
            display: block;
            margin: 2px 1px;
            font-size: 0.9em;
            color: var(--dark-gray);
        }
        .filter-controls input[type="range"] {
            width: calc(100% - 20px); /* Adjust for padding/margin */
            margin-top: 5px;
        }
        .range-values {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: var(--dark-gray);
            margin-top: -5px; /* Align better with slider */
        }
        .filter-controls input[type="checkbox"],
        .filter-controls input[type="radio"] {
            margin-right: 8px;
        }
        .checkbox-group, .radio-group {
            max-height: 150px; /* Limit height for long lists */
            overflow-y: auto;
            padding: 5px;
            border: 1px solid var(--light-gray);
            border-radius: 4px;
            margin-top: 5px;
        }
        .checkbox-group div, .radio-group div {
            display: flex;
            margin-bottom: 3px;
        }

        .overlay-selector {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed var(--medium-gray);
        }
        .overlay-selector label {
            display: inline-block;
            margin-right: 10px;
            font-weight: normal;
        }

        /* Utilities */
        .hidden {
            display: none !important;
        }
        .inline {
            display: inline-flex !important;
        }
        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
            margin-right: 10px; /* Spacing between buttons */
        }
        .btn:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .btn-secondary {
            background-color: var(--dark-gray);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #555;
        }

        /* Leaflet Popup */
        .popup-content {
            max-width: 350px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9em;
        }
        .popup-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 5px;
        }
        .popup-table th, .popup-table td {
            border: 1px solid var(--medium-gray);
            padding: 6px 8px;
            text-align: left;
        }
        .popup-table th {
            background-color: var(--light-gray);
            white-space: nowrap;
            font-weight: bold;
        }

        /* Responsive */
        @media (min-width: 992px) {
            #map-section-content {
                flex-direction: row; /* Side-by-side on larger screens */
            }
            #map-controls {
                width: 350px; /* Fixed width for controls */
                max-height: calc(100vh - 200px); /* Limit height */
            }
             #map-wrapper {
                min-height: 600px; /* Taller map on large screens */
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>DropMap</h1>
    </header>

    <main>
        <!-- Upload Section -->
        <section id="upload-section">
            <h2>Upload File</h2>
            <p>Drag and drop your Excel (XLSX, XLS) or CSV file, or use the browse button.</p>
            <div id="drop-area" class="drop-area">
                <h3>Drop File Here</h3>
                <p>or</p>
                <input type="file" id="file-input" accept=".xlsx,.xls,.csv" class="hidden">
                <button id="browse-btn" class="btn">Browse Files</button>
            </div>
        </section>

        <!-- 2. Data View Section -->
        <section id="data-section" class="hidden">
            <h2>Data Preview & Preparation</h2>

            <div id="file-info">
                <h3>File Information:</h3>
                <div class="file-info-grid">
                    <p id="file-name">Name: -</p>
                    <p id="file-type">Type: -</p>
                    <p id="sheet-count">Sheets: -</p>
                    <p id="row-count">Rows: -</p>
                </div>
            </div>

            <div id="preview-container">
                <h3>Data Preview (First 10 rows):</h3>
                <div id="sheet-selector-container">
                    <!-- Sheet selector dropdown will be added here -->
                </div>
                <div id="table-container">
                    <!-- Data table preview will be added here -->
                </div>
            </div>

            <div id="actions-container">
                <button id="postcode-btn" class="btn btn-secondary" disabled>Extract Postcodes</button>
                <button id="geocode-btn" class="btn btn-secondary" disabled>Geocode Postcodes (UK)</button>
                <button id="map-btn" class="btn" disabled>Create Map</button>
                <div id="preparation-status">Geocoding status will appear here. Uses postcodes.io (UK only).</div>
            </div>
        </section>

        <!-- 3. Map View Section -->
        <section id="map-section" class="hidden">
            <h2>Map Visualization</h2>
            <div id="map-section-content">
                <aside id="map-controls">
                    <h3>Map Filters & Overlays</h3>
                    <form id="filters-form">
                         <fieldset class="filter-fieldset">
                            <legend>Overlay</legend>
                            <div id="overlay-options" class="filter-controls radio-group">
                                <!-- Overlay radio buttons generated here -->
                                <div>
                                    <input type="radio" id="overlay-none" name="overlay-column" value="none" checked>
                                    <label for="overlay-none">None</label>
                                </div>
                            </div>
                        </fieldset>
                        <div id="column-filters">
                            <!-- Dynamic filters will be added here -->
                        </div>
                    </form>
                </aside>
                <div id="map-wrapper">
                    <div id="map"></div>
                     <div id="map-legend" class="hidden">
                        <button id="hide-legend">X</button>
                        <h4>Legend</h4>
                        <div id="legend-items"></div>
                    </div>
                </div>
            </div>
        </section>
        <section id="logs-section" class="hidden">
            <button id="log-btn" class="btn" disabled>Download Log</button>
        </section>
    </main>

</body>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Elements ---
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const browseBtn = document.getElementById('browse-btn');
        // Data Section Elements
        const dataSection = document.getElementById('data-section');
        const fileInfoDiv = document.getElementById('file-info');
        const fileNameEl = document.getElementById('file-name');
        const fileTypeEl = document.getElementById('file-type');
        const sheetCountEl = document.getElementById('sheet-count');
        const rowCountEl = document.getElementById('row-count');
        const previewContainer = document.getElementById('preview-container');
        const sheetSelectorContainer = document.getElementById('sheet-selector-container');
        const tableContainer = document.getElementById('table-container');
        const postcodeBtn = document.getElementById('postcode-btn');
        const geocodeBtn = document.getElementById('geocode-btn');
        const preparationStatusEl = document.getElementById('preparation-status');
        const mapBtn = document.getElementById('map-btn');
        // Map Section Elements
        const mapSection = document.getElementById('map-section');
        const mapControls = document.getElementById('map-controls');
        const columnFiltersContainer = document.getElementById('column-filters');
        const overlayOptionsContainer = document.getElementById('overlay-options');
        const mapWrapper = document.getElementById('map-wrapper');
        const mapDiv = document.getElementById('map');
        const mapLegend = document.getElementById('map-legend');
        const hideLegend = document.getElementById('hide-legend');
        const legendItems = document.getElementById('legend-items');
        // Loging Elements
        const logSection = document.getElementById('logs-section')
        const logBtn = document.getElementById('log-btn')

        // --- State Variables ---
        let fileData = null; // { type: 'csv'/'excel', data/sheets: {...} }
        let currentSheetData = null; // Array of arrays for the selected sheet/CSV
        let currentHeaders = [];
        let columnInfo = {}; // { header, type, index }
        let locationColumns = {address:-1, postcode: -1, lat: -1, long: -1 }; // Indices

        let map = null;
        let mapMarkers = []; // Array of Leaflet marker instances
        let originalMarkerData = []; // Array of { marker, data: rowDataArray }
        let activeOverlayColumnIndex = -1; // Track which column is used for overlay

        // --- Constants ---
        const PREVIEW_ROW_LIMIT = 10;
        const ADDRESS_COLUMNS = ['address', 'full address', 'address1', 'address 1'];
        const POSTCODE_COLUMNS = ['postcode', 'post code', 'postal code', 'zip', 'zipcode'];
        const LAT_COLUMNS = ['latitude', 'lat', 'lattitude', 'y'];
        const LONG_COLUMNS = ['longitude', 'long', 'lng', 'lon', 'x'];
        const GEOCODE_API = 'https://api.postcodes.io/postcodes/';
        const GEOCODE_BATCH_LIMIT = 90; // postcodes.io allows 100 per request
        const GEOCODE_DELAY = 100; // ms delay between batches

        // --- Initialization ---
        setupEventListeners();

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Drag and Drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, () => dropArea.classList.add('active'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, () => dropArea.classList.remove('active'), false);
            });
            dropArea.addEventListener('drop', handleDrop, false);

            // Browse Button
            browseBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect, false);

            // Action Buttons
            postcodeBtn.addEventListener('click', extractPostcodes);
            geocodeBtn.addEventListener('click', handleGeocodeClick);
            mapBtn.addEventListener('click', handleMapClick);

            // Overlay Radio Buttons (Event delegation on the container)
            overlayOptionsContainer.addEventListener('change', handleOverlayChange);
        }

        // --- Drag/Drop & File Input Handlers ---
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            handleFiles(dt.files);
        }

        function handleFileSelect(e) {
            handleFiles(e.target.files);
        }

        function handleFiles(files) {
            if (!files || files.length === 0) return;
            const file = files[0];

            // Reset UI
            resetUI();

            fileNameEl.textContent = `Name: ${file.name}`;
            const fileExt = file.name.split('.').pop().toLowerCase();
            const isCsv = fileExt === 'csv';
            fileTypeEl.textContent = `Type: ${isCsv ? 'CSV' : 'Excel'}`;

            const reader = new FileReader();
            reader.onload = (e) => {
                const fileContent = e.target.result;
                if (isCsv) {
                    parseCsv(fileContent, file);
                } else {
                    parseExcel(fileContent);
                }
            };
            if (isCsv) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        // --- Parsing Functions ---
        function parseCsv(csvString, file) {
             Papa.parse(file, {
                header: true,
                dynamicTyping: true, // Attempts to convert numbers/booleans
                skipEmptyLines: true,
                complete: (results) => {
                    if (results.errors.length > 0) {
                        console.error("CSV Parsing Errors:", results.errors);
                        alert(`Error parsing CSV: ${results.errors[0].message}. Please check file format.`);
                        return;
                    }
                    if (!results.data || results.data.length === 0) {
                        alert("CSV file appears to be empty or header-only.");
                        return;
                    }

                    fileData = { type: 'csv', data: results.data };
                    sheetCountEl.textContent = 'Sheets: 1 (CSV)';
                    rowCountEl.textContent = `Rows: ${results.data.length}`;

                    // Convert PapaParse data [{header: val,...}] to array of arrays [[header,...], [val,...]]
                    currentHeaders = results.meta.fields;
                    currentSheetData = [currentHeaders, ...results.data.map(row => currentHeaders.map(h => row[h]))];

                    processLoadedData();
                },
                 error: (error) => {
                     console.error("CSV Parsing Failed:", error);
                     alert(`Failed to parse CSV file: ${error.message}`);
                 }
            });
        }

        function parseExcel(arrayBuffer) {
            try {
                const workbook = XLSX.read(arrayBuffer, { type: 'array', cellDates: true });
                const sheetNames = workbook.SheetNames;

                if (sheetNames.length === 0) {
                    alert("Excel file contains no sheets.");
                    return;
                }

                fileData = { type: 'excel', workbook: workbook, sheets: {} };
                let totalRows = 0;

                // Store all sheets as array of arrays immediately
                sheetNames.forEach(sheetName => {
                    const worksheet = workbook.Sheets[sheetName];
                    const sheetJson = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                    let lastNonEmptyRow = -1;
                    for(let i = sheetJson.length - 1; i >= 0; i--) {
                        if (sheetJson[i].some(cell => cell !== null && cell !== '')) {
                            lastNonEmptyRow = i;
                            break;
                        }
                    }
                    const cleanedData = sheetJson.slice(0, lastNonEmptyRow + 1);
                    fileData.sheets[sheetName] = cleanedData;
                    totalRows += Math.max(0, cleanedData.length -1);
                });

                sheetCountEl.textContent = `Sheets: ${sheetNames.length}`;
                rowCountEl.textContent = `Total Rows: ${totalRows}`;

                displayExcelSheetSelector(sheetNames);
                // Load and process the first sheet by default
                loadSheetData(sheetNames[0]);

            } catch (error) {
                console.error('Error parsing Excel file:', error);
                alert('Error parsing Excel file. It might be corrupted or in an unsupported format.');
            }
        }

        // --- Data Loading and Processing ---
        function loadSheetData(sheetName) {
          if (!fileData || fileData.type !== 'excel' || !fileData.sheets[sheetName]) return; // Only excel files have sheets.
          currentSheetData = fileData.sheets[sheetName];
          currentHeaders = currentSheetData.length > 0 ? currentSheetData[0] : [];
          processLoadedData();
        }

        function processLoadedData() {
             if (!currentSheetData || currentSheetData.length === 0) {
                 alert("Selected sheet appears to be empty.");
                 // Maybe clear preview and disable buttons?
                 tableContainer.innerHTML = "<p>No data to display.</p>";
                 geocodeBtn.disabled = true;
                 mapBtn.disabled = true;
                 return;
             }
             analyzeColumns();
             displayDataPreview();

             // Update UI State
             dataSection.classList.remove('hidden');
             // Enable postcode extract button if address column found
             postcodeBtn.disabled = locationColumns.address === -1;
             // Enable geocode if a postcode column is found
             geocodeBtn.disabled = locationColumns.postcode === -1;
             // Enable map button if lat/long columns are found
             mapBtn.disabled = !(locationColumns.lat !== -1 && locationColumns.long !== -1);

             preparationStatusEl.textContent = locationColumns.postcode !== -1
                 ? "Ready."
                 : "No postcode column detected for geocoding.";

             // If map section was previously visible, hide it until 'Create Map' is clicked again
             mapSection.classList.add('hidden');
             if (map) {
                map.remove();
                map = null;
             }
             // Reveal logs section
             logSection.classList.remove('hidden');
        }

        function analyzeColumns() {
            columnInfo = {}; // Reset column info
            locationColumns = {address:-1, postcode: -1, lat: -1, long: -1 };

            if (!currentHeaders || currentHeaders.length === 0) return;

            currentHeaders.forEach((header, index) => {
             const headerStr = header ? header.toString().toLowerCase().trim() : undefined;

             // Check for Location Columns
             if (locationColumns.address === -1 && ADDRESS_COLUMNS.includes(headerStr)) {
                 locationColumns.address = index;
             }
             if (locationColumns.postcode === -1 && POSTCODE_COLUMNS.includes(headerStr)) {
                 locationColumns.postcode = index;
             }
             if (locationColumns.lat === -1 && LAT_COLUMNS.includes(headerStr)) {
                 locationColumns.lat = index;
             }
             if (locationColumns.long === -1 && LONG_COLUMNS.includes(headerStr)) {
                 locationColumns.long = index;
             }

             // Get column data
             const columnData = currentSheetData.slice(1).map(row => row[index]);
             colType = detectColumnType(header, columnData);

             columnInfo[index] = { header: header || `Column ${index + 1}`, type: colType, index: index };
            });

            console.log("Detected Location Columns:", locationColumns);
            console.log("Column Analysis:", columnInfo);
        }

        // --- UI Update Functions ---
        function resetUI() {
            dataSection.classList.add('hidden');
            mapSection.classList.add('hidden');
            fileData = null;
            currentSheetData = null;
            currentHeaders = [];
            columnInfo = {};
            locationColumns = { address: -1, postcode: -1, lat: -1, long: -1 };
            sheetSelectorContainer.innerHTML = '';
            tableContainer.innerHTML = '';
            columnFiltersContainer.innerHTML = '';
            overlayOptionsContainer.innerHTML = '<div><input type="radio" id="overlay-none" name="overlay-column" value="none" checked><label for="overlay-none">None</label></div>'; // Reset overlays
            preparationStatusEl.textContent = '';
            fileNameEl.textContent = 'Name: -';
            fileTypeEl.textContent = 'Type: -';
            sheetCountEl.textContent = 'Sheets: -';
            rowCountEl.textContent = 'Rows: -';
            geocodeBtn.disabled = true;
            mapBtn.disabled = true;
            if (map) {
                map.remove();
                map = null;
            }
            mapMarkers = [];
            originalMarkerData = [];
            activeOverlayColumnIndex = -1;
            mapLegend.classList.add('hidden');
        }

        function displayExcelSheetSelector(sheetNames) {
            sheetSelectorContainer.innerHTML = '<strong>Select Sheet: </strong>';
            const select = document.createElement('select');
            select.id = 'sheet-select';
            sheetNames.forEach(sheetName => {
                const option = document.createElement('option');
                option.value = sheetName;
                option.textContent = sheetName;
                select.appendChild(option);
            });
            select.addEventListener('change', (e) => {
                // Load and process the newly selected sheet
                loadSheetData(e.target.value);
            });
            sheetSelectorContainer.appendChild(select);
        }

        function displayDataPreview() {
            tableContainer.innerHTML = ''; // Clear previous
            if (!currentSheetData || currentSheetData.length === 0) {
                 tableContainer.innerHTML = "<p>No data to display.</p>";
                 return;
            }

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            currentHeaders.forEach((header, index) => {
                const th = document.createElement('th');
                th.textContent = header !== null ? header : `Column ${index + 1}`;
                // Optionally highlight detected location columns
                if (index === locationColumns.lat || index === locationColumns.long || index === locationColumns.postcode) {
                    th.style.backgroundColor = '#d4edda'; // Light green
                    th.title = index === locationColumns.postcode ? 'Postcode Column' : 'Coordinate Column';
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            const previewData = currentSheetData.slice(1, PREVIEW_ROW_LIMIT + 1);

            previewData.forEach(row => {
                const tr = document.createElement('tr');
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.textContent = cell !== null && cell !== undefined ? cell : '';
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            tableContainer.appendChild(table);

             // Update row count display for the current sheet/CSV
             const dataRowCount = currentSheetData.length > 0 ? currentSheetData.length - 1 : 0;
             rowCountEl.textContent = `Rows (current): ${dataRowCount}`;
        }
        // --- Extract Postcodes ---
        async function extractPostcodes() {
            const postcodeRegex = /[a-zA-Z]{1,2}\d{1,2}[a-zA-Z]?\s\d[a-zA-Z]{2}/g
            // Ensure Postcode header exists, add if necessary
            if (locationColumns.postcode === -1) {
                currentHeaders.push('Postcode');
                locationColumns.postcode = currentHeaders.length - 1;
                // Add null placeholder to all data rows for the new column
                 currentSheetData.slice(1).forEach(row => row.push(null));
            }
            // Add new headers back to the first row
            currentSheetData[0] = currentHeaders;

            // Identify rows needing geocoding
            const rowsToExtract = currentSheetData.slice(1).filter(row => {
                const postcode = row[locationColumns.postcode];
                // Needs extraction if postcode does not exist
                return !postcode;
            });
            if (rowsToExtract.length === 0) {
                preparationStatusEl.textContent = 'Postcode present for all rows.';
                console.log(preparationStatusEl.textContent)
                return;
            }
            preparationStatusEl.textContent = `Found ${rowsToExtract.length} rows potentially missing postcodes.`;
            console.log(preparationStatusEl.textContent)
            let postcodeCount = 0;
            let failedCount = 0;

            // Process
            for (let i = 0; i < rowsToExtract.length; i += 1) {
                const row = rowsToExtract[i]
                const address = row[locationColumns.address]?.toString().trim();
                if (address.length === 0) continue;

                preparationStatusEl.textContent = `Extracting postcode for ${address}`;
                console.log(preparationStatusEl.textContent)
                const postcodeMatch = address.match(postcodeRegex)
                const postcode = postcodeMatch ? postcodeMatch[0] : null;
                if (postcode) {
                    row[locationColumns.postcode] = postcode;
                    postcodeCount++;
                } else {
                    console.warn(`Couldn't find postcode in '${address}'.`);
                    failedCount++;
                }
            }

            preparationStatusEl.textContent = `Postcode extraction complete. Successful: ${postcodeCount}, Failed/Not Found: ${failedCount}.`;
            console.log(preparationStatusEl.textContent)
            preparationStatusEl.classList.add('success');
            await new Promise(resolve => setTimeout(resolve, 3000));
            preparationStatusEl.classList.remove('success')

            processLoadedData(); // Re-analyze columns, updates preview, and button states
        }

        // --- Geocoding ---
        async function handleGeocodeClick() {
            if (locationColumns.postcode === -1) {
                alert('Cannot geocode: Postcode column not identified.');
                return;
            }

            postcodeBtn.disabled = true;
            geocodeBtn.disabled = true;
            mapBtn.disabled = true; // Disable map creation during geocoding
            preparationStatusEl.textContent = 'Preparing data for geocoding...';

            // Ensure Lat/Long headers exist, add if necessary
            if (locationColumns.lat === -1) {
                currentHeaders.push('Latitude');
                locationColumns.lat = currentHeaders.length - 1;
                // Add null placeholder to all data rows for the new column
                currentSheetData.slice(1).forEach(row => row.push(null));
            }
             if (locationColumns.long === -1) {
                currentHeaders.push('Longitude');
                locationColumns.long = currentHeaders.length - 1;
                currentSheetData.slice(1).forEach(row => row.push(null));
            }

            // Add new headers back to the first row
            currentSheetData[0] = currentHeaders;

            // Identify rows needing geocoding
            const rowsToGeocode = currentSheetData.slice(1).filter(row => {
                const postcode = row[locationColumns.postcode];
                const lat = row[locationColumns.lat];
                const long = row[locationColumns.long];
                // Needs geocoding if postcode exists and lat or long is missing/invalid
                return postcode && (!lat || !long || isNaN(parseFloat(lat)) || isNaN(parseFloat(long)));
            });
            if (rowsToGeocode.length === 0) {
                preparationStatusEl.textContent = 'No rows require geocoding (Postcode present and Lat/Long already exist).';
                console.log(preparationStatusEl.textContent)
                geocodeBtn.disabled = false; // Re-enable geocode button
                mapBtn.disabled = !(locationColumns.lat === -1 || locationColumns.long === -1); // Re-enable map button if coords are valid
                return;
            }
            preparationStatusEl.textContent = `Found ${rowsToGeocode.length} rows potentially needing geocoding. Starting... (Using ${GEOCODE_API})`;
            console.log(preparationStatusEl.textContent)
            let geocodedCount = 0;
            let failedCount = 0;

            // Process in batches using postcodes.io bulk lookup
            for (let i = 0; i < rowsToGeocode.length; i += GEOCODE_BATCH_LIMIT) {
                const batch = rowsToGeocode.slice(i, i + GEOCODE_BATCH_LIMIT);
                const postcodesToLookup = batch.map(row => row[locationColumns.postcode]?.toString().trim()).filter(pc => pc); // Get valid postcodes for the batch

                if (postcodesToLookup.length === 0) continue;

                preparationStatusEl.textContent = `Geocoding batch ${Math.floor(i / GEOCODE_BATCH_LIMIT) + 1}... (${geocodedCount} successful, ${failedCount} failed)`;
                console.log(preparationStatusEl.textContent)
                try {
                    const response = await fetch(GEOCODE_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ postcodes: postcodesToLookup })
                    });

                    if (!response.ok) {
                        // Handle HTTP errors (e.g., 400, 500)
                        console.error('HTTP error during geocoding:', response.status, response.statusText);
                        preparationStatusEl.textContent = `Geocoding failed: HTTP ${response.status} ${response.statusText}`;
                        failedCount += postcodesToLookup.length; // Assume all failed
                        geocodeBtn.disabled = false;
                        mapBtn.disabled = !(locationColumns.lat === -1 || locationColumns.long === -1);
                        return;
                    }
                    const results = await response.json();

                    if (results.status === 200) {
                        results.result.forEach(item => {
                            if (item.result) { // Successfully geocoded
                                const { latitude, longitude } = item.result;
                                // Find corresponding original rows and update lat/long
                                batch.forEach(originalRow => {
                                    if (originalRow[locationColumns.postcode]?.toString().trim() === item.query) {
                                        originalRow[locationColumns.lat] = latitude;
                                        originalRow[locationColumns.long] = longitude;
                                    }
                                });
                                geocodedCount++;
                            } else {
                                // Lookup happened but postcode was invalid according to API
                                console.warn(`Geocoding query for '${item.query}' failed (Invalid Postcode?).`);
                                failedCount++;
                            }
                        });
                    } else {
                        console.error('Bulk geocoding API error:', results.error);
                        failedCount += postcodesToLookup.length; // Assume all in batch failed on API error
                    }
                } catch (error) {
                    console.error('Network error during geocoding:', error);
                    failedCount += postcodesToLookup.length; // Assume all in batch failed on network error
                    preparationStatusEl.textContent = `Geocoding error: ${error.message}. Stopping.`;
                    geocodeBtn.disabled = false; // Re-enable buttons on failure
                    mapBtn.disabled = !(locationColumns.lat === -1 || locationColumns.long === -1);
                    return; // Stop geocoding on critical error
                }

                // Delay between batches to be nice to the API
                if (i + GEOCODE_BATCH_LIMIT < rowsToGeocode.length) {
                    await new Promise(resolve => setTimeout(resolve, GEOCODE_DELAY));
                }
            }

            if (geocodedCount === rowsToGeocode.length) {
                preparationStatusEl.textContent = `Geocoding complete. Successful: ${geocodedCount}, Failed/Not Found: ${failedCount}.`;
                console.log(preparationStatusEl.textContent)
                preparationStatusEl.classList.add('success');
                await new Promise(resolve => setTimeout(resolve, 3000));
                preparationStatusEl.classList.remove('success')
            }
            processLoadedData(); // Re-analyze columns, updates preview, and button states
        }

        // --- Mapping ---
        function handleMapClick() {
            if (locationColumns.lat === -1 || locationColumns.long === -1) {
                alert('Cannot create map: Latitude or Longitude columns not identified.');
                return;
            }
             if (!currentSheetData || currentSheetData.length <= 1) {
                 alert('Cannot create map: No data rows found.');
                 return;
             }

            mapSection.classList.remove('hidden');
            mapBtn.disabled = true;

            // Use setTimeout to allow the UI to update (show the section) before map init
            setTimeout(() => {
                createLeafletMap();
                createFilterControls();
                mapBtn.disabled = false;
                // Scroll to map section for better UX
                 mapSection.scrollIntoView({ behavior: 'smooth' });
            }, 50);
        }

        function createLeafletMap() {
            // Clear previous map instance if exists
            if (map) {
                map.remove();
                map = null;
                mapMarkers = [];
                originalMarkerData = [];
            }

            mapDiv.innerHTML = '';
            map = L.map('map').setView([54.5, -4], 6);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 18,
            }).addTo(map);

            const bounds = [];
            const dataRows = currentSheetData.slice(1);

            function jitterCoordinate(coord, amount = 0.0005) {  // Amount is the maximum offset
                const plusOrMinus = Math.random() < 0.5 ? -1 : 1;
                return coord + plusOrMinus * Math.random() * amount;
            }

            const seenCoordinates = {};

            dataRows.forEach((row, rowIndex) => {
                const lat = parseFloat(row[locationColumns.lat]);
                const long = parseFloat(row[locationColumns.long]);

                const coordKey = `${lat.toFixed(6)},${long.toFixed(6)}`; // Use 6 decimal places for comparison

                if (!isNaN(lat) && !isNaN(long)) {
                    let displayLat = lat;
                    let displayLong = long;

                    if (seenCoordinates[coordKey]) {
                        // Offset the coordinates
                        displayLat = jitterCoordinate(lat);
                        displayLong = jitterCoordinate(long);
                    }

                    seenCoordinates[coordKey] = true;
                    const marker = L.marker([displayLat, displayLong]);
                    marker.bindPopup(createPopupContent(row));

                    // Store original data with the marker
                    originalMarkerData.push({ marker: marker, data: row, originalIndex: rowIndex + 1 });
                    mapMarkers.push(marker);
                    marker.addTo(map);
                    bounds.push([displayLat, displayLong]);
                } else {
                    // Keep track of rows that couldn't be mapped
                    console.warn(`Skipping row ${rowIndex + 1}: Invalid Lat/Long (${row[locationColumns.lat]}, ${row[locationColumns.long]})`);
                }
            });

            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [50, 50], maxZoom: 16 });
            } else {
                 // Handle case where no valid coordinates were found
                 alert("No valid coordinates found in the data to display on the map.");
                 // Optionally hide map section again or show a message
                 mapSection.classList.add('hidden');
                 return;
            }
            // Apply initial overlay if one was selected (unlikely state, but for robustness)
            applyOverlayStyle();
        }

        function createPopupContent(rowData) {
            const popupDiv = document.createElement('div');
            popupDiv.className = 'popup-content';
            const table = document.createElement('table');
            table.className = 'popup-table';

            currentHeaders.forEach((header, index) => {
                const tr = document.createElement('tr');
                const th = document.createElement('th');
                th.textContent = header;
                const td = document.createElement('td');
                const value = rowData[index];
                td.textContent = value !== null && value !== undefined ? value : 'N/A';
                tr.appendChild(th);
                tr.appendChild(td);
                table.appendChild(tr);
            });

            popupDiv.appendChild(table);
            return popupDiv;
        }
        // Format date for display
        const formatDate = (timestamp) => {
            const date = new Date(parseInt(timestamp));
            return date.toLocaleDateString("en-GB", { year: 'numeric', month: '2-digit', day: '2-digit'});
        };

        // --- Filtering and Overlays ---
        function createFilterControls() {
            columnFiltersContainer.innerHTML = ''; // Clear existing filters
            overlayOptionsContainer.innerHTML = '<div><input type="radio" id="overlay-none" name="overlay-column" value="none" checked><label for="overlay-none">None</label></div>'; // Reset overlays

            Object.values(columnInfo).forEach(col => {
                // Don't create filters for lat/long/postcode or non-filterable types
                if (col.index === locationColumns.lat || col.index === locationColumns.long || col.index === locationColumns.postcode ||
                    ['identifier', 'text-unique', 'unknown', 'null-column', 'text'].includes(col.type)) {
                    return;
                }

                const fieldset = document.createElement('fieldset');
                fieldset.className = 'filter-fieldset';
                const legend = document.createElement('legend');
                legend.textContent = col.header;
                fieldset.appendChild(legend);

                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'filter-controls';
                controlsDiv.dataset.columnIndex = col.index; // Store index for filtering

                // Use two sliders for range filtering
                const createSlider = (coltype, id, labelText, defaultValue, min, max, step) => {
                    const label = document.createElement('label');
                    label.htmlFor = id;
                    label.textContent = labelText;

                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.id = id;
                    slider.min = min;
                    slider.max = max;
                    slider.step = step
                    slider.value = defaultValue;

                    // Set initial value for the slider
                    const valueSpan = document.createElement('span');
                    if (coltype === 'date'){
                        valueSpan.textContent = ` ${formatDate(defaultValue)}`;
                    } else if (coltype === 'numeric') {
                        valueSpan.textContent = ` ${parseFloat(defaultValue).toFixed(2)}`;
                    } else {
                        valueSpan.textContent = ` ${parseInt(defaultValue)}`;
                    }

                    // Update slider value on input
                    slider.addEventListener('input', debounce(() => {
                        if (coltype === 'date'){
                            valueSpan.textContent = ` ${formatDate(slider.value)}`;
                        } else if (coltype === 'numeric') {
                            valueSpan.textContent = ` ${parseFloat(slider.value).toFixed(2)}`;
                        } else {
                            valueSpan.textContent = ` ${parseInt(slider.value)}`;
                        }
                        applyFilters();
                    }, 250));

                    // Create inline div for slider
                    const sliderDiv = document.createElement('div');
                    sliderDiv.classList = 'inline';
                    sliderDiv.appendChild(slider);

                    // Add all to controls
                    controlsDiv.appendChild(label);
                    controlsDiv.appendChild(valueSpan);
                    controlsDiv.appendChild(sliderDiv);
                    return slider;
                };
                const addDatePicker = (sliderId, sliderElement) => {
                    // Add a calendar icon or date picker for better UX
                    const datePickerBtn = document.createElement('button');
                    datePickerBtn.innerHTML = '📅';
                    datePickerBtn.title = 'Select date';
                    datePickerBtn.className = 'date-picker-btn';
                    datePickerBtn.style.marginLeft = '5px';

                    datePickerBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        const dateInput = document.createElement('input');
                        dateInput.type = 'date';
                        dateInput.value = new Date(parseInt(sliderElement.value)).toISOString().split('T')[0];
                        console.log("Date selected", dateInput.value)

                        dateInput.addEventListener('change', () => {
                            const selectedDate = new Date(dateInput.value);
                            if (!isNaN(selectedDate.getTime())) {
                                sliderElement.value = selectedDate.getTime();
                                sliderElement.dispatchEvent(new Event('input'));
                            }
                            dateInput.remove();
                        });

                        // Insert after the button
                        datePickerBtn.parentNode.insertBefore(dateInput, datePickerBtn.nextSibling);
                        dateInput.focus();
                    });

                    sliderElement.parentNode.insertBefore(datePickerBtn, sliderElement.nextSibling);
                };
                const createCheckbox = (id, labelText) => {
                    const div = document.createElement('div');
                    div.className = 'inline checkbox';
                    const span = document.createElement('span');
                    span.textContent = labelText;
                    div.appendChild(span);
                    const checkbox = document.createElement('input');
                    const checkboxId = `filter-${id}-blank`;
                    checkbox.type = 'checkbox';
                    checkbox.id = checkboxId;
                    checkbox.checked = true;
                    checkbox.addEventListener('change', applyFilters);
                    div.appendChild(checkbox);
                    return div;
                };

                // --- Create Overlay Option ---
                const overlayDiv = document.createElement('div');
                const radioId = `overlay-${col.index}`;
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.id = radioId;
                radio.name = 'overlay-column';
                radio.value = col.index;
                const label = document.createElement('label');
                label.htmlFor = radioId;
                label.textContent = col.header;
                overlayDiv.appendChild(radio);
                overlayDiv.appendChild(label);
                overlayOptionsContainer.appendChild(overlayDiv);

                // --- Create Filter Controls ---
                const dataRows = currentSheetData.slice(1);

                if (col.type === 'date') {
                    // Extract dates and convert to timestamps for easier manipulation
                    const dates = dataRows.map(row => {
                        const dateValue = new Date(row[col.index]);
                        return isNaN(dateValue) || dateValue.getTime() === 0 ? null : dateValue.getTime();
                    }).filter(v => v !== null);

                    if (dates.length === 0) return;

                    const dayInMs = 24 * 60 * 60 * 1000; // 1 day in milliseconds

                    const minTimestamp = Math.min(...dates) - dayInMs; // Pad the min values
                    const maxTimestamp = Math.max(...dates) + dayInMs; // Pad the max values

                    const stepSize = Math.min(dayInMs, (maxTimestamp - minTimestamp) / 100 || dayInMs);

                    const minSlider = createSlider(col.type, `filter-min-${col.index}`, `From:`, minTimestamp,  minTimestamp, maxTimestamp, stepSize);
                    const maxSlider = createSlider(col.type, `filter-max-${col.index}`, `To:`, maxTimestamp, minTimestamp, maxTimestamp, stepSize);
                    const blankSelector = createCheckbox(col.index, `Blank:`);
                    controlsDiv.appendChild(blankSelector);

                    // Ensure min <= max constraint
                    let isSyncing = false;
                    minSlider.addEventListener('input', () => {
                        if (isSyncing) return;
                        const minValue = parseInt(minSlider.value);
                        const maxValue = parseInt(maxSlider.value);
                        if (minValue > maxValue) {
                            isSyncing = true;
                            maxSlider.value = minValue;
                            maxSlider.dispatchEvent(new Event('input'));
                            isSyncing = false;
                        }
                    });
                    maxSlider.addEventListener('input', () => {
                        if (isSyncing) return;
                        const maxValue = parseInt(maxSlider.value);
                        const minValue = parseInt(minSlider.value);
                        if (maxValue < minValue) {
                            isSyncing = true;
                            minSlider.value = maxValue;
                            minSlider.dispatchEvent(new Event('input'));
                            isSyncing = false;
                        }
                    });
                    // Add date pickers (optional)
                    addDatePicker(`picker-min-${col.index}`, minSlider);
                    addDatePicker(`picker-max-${col.index}`, maxSlider);
                } else if (col.type === 'numeric') {
                    const values = dataRows.map(row => parseFloat(row[col.index])).filter(v => !isNaN(v));
                    if (values.length === 0) return;

                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const stepSize = (max - min) / 100 || 0.01;

                    const minSlider = createSlider(col.type, `filter-min-${col.index}`, `Min:`, min, min, max, stepSize);
                    const maxSlider = createSlider(col.type, `filter-max-${col.index}`, `Max:`, max, min, max, stepSize);
                    const blankSelector = createCheckbox(col.index, `Blank:`);
                    controlsDiv.appendChild(blankSelector);

                    // Ensure min <= max constraint
                    let isSyncing = false;
                    minSlider.addEventListener('input', () => {
                        if (isSyncing) return;
                        const minValue = parseFloat(minSlider.value);
                        const maxValue = parseFloat(maxSlider.value);
                        if (minValue > maxValue) {
                            isSyncing = true;
                            maxSlider.value = minValue;
                            maxSlider.dispatchEvent(new Event('input'));
                            isSyncing = false;
                        }
                    });
                    maxSlider.addEventListener('input', () => {
                        if (isSyncing) return;
                        const maxValue = parseFloat(maxSlider.value);
                        const minValue = parseFloat(minSlider.value);
                        if (maxValue < minValue) {
                            isSyncing = true;
                            minSlider.value = maxValue;
                            minSlider.dispatchEvent(new Event('input'));
                            isSyncing = false;
                        }
                    });
                } else if (col.type === 'categorical') {
                    const uniqueValues = [...new Set(dataRows.map(row => row[col.index]?.toString().trim() || '(Blank)'))].sort();
                    if (uniqueValues.length === 0 || uniqueValues.length > 25) return;
                    const checkboxGroup = document.createElement('div');
                    checkboxGroup.className = 'checkbox-group';
                    uniqueValues.forEach(value => {
                        const div = document.createElement('div');
                        const checkboxId = `filter-${col.index}-${value.replace(/[^a-zA-Z0-9]/g, '')}`;
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = checkboxId;
                        checkbox.value = value;
                        checkbox.checked = true;
                        checkbox.addEventListener('change', applyFilters);
                        const label = document.createElement('label');
                        label.htmlFor = checkboxId;
                        label.textContent = value;
                        div.appendChild(checkbox);
                        div.appendChild(label);
                        checkboxGroup.appendChild(div);
                    });
                    controlsDiv.appendChild(checkboxGroup);
                } else if (col.type === 'boolean') {
                    const radioGroup = document.createElement('div');
                    radioGroup.className = 'radio-group';
                    const options = ['all', 'true', 'false'];
                    options.forEach(option => {
                        const div = document.createElement('div');
                        const radioId = `filter-${col.index}-${option}`;
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.name = `filter-bool-${col.index}`;
                        radio.id = radioId;
                        radio.value = option;
                        radio.checked = option === 'all';
                        radio.addEventListener('change', applyFilters);
                        const label = document.createElement('label');
                        label.htmlFor = radioId;
                        label.textContent = option.charAt(0).toUpperCase() + option.slice(1);
                        div.appendChild(radio);
                        div.appendChild(label);
                        radioGroup.appendChild(div);
                    });
                    // Create button for including blanks
                    const blankSelector = createCheckbox(col.index, `Blank:`);
                    controlsDiv.appendChild(radioGroup);
                    controlsDiv.appendChild(blankSelector);
                }
                //
                fieldset.appendChild(controlsDiv);
                columnFiltersContainer.appendChild(fieldset);
            });
        }

        function applyFilters() {
            if (!map || originalMarkerData.length === 0) return;

            // Clear previous filters
            const activeFilters = {};
            columnFiltersContainer.querySelectorAll('.filter-controls').forEach(controlDiv => {
                const colIndex = parseInt(controlDiv.dataset.columnIndex);
                const colName = columnInfo[colIndex]['header'];
                const colType = columnInfo[colIndex]?.type;

                if (colType === 'date') {
                    const minSlider = controlDiv.querySelector(`#filter-min-${colIndex}`);
                    const maxSlider = controlDiv.querySelector(`#filter-max-${colIndex}`);
                    const blanksCheckbox = controlDiv.querySelector(`#filter-${colIndex}-blank`);
                    if (minSlider && maxSlider) {
                        activeFilters[colIndex] = {
                            name: colName,
                            type: 'date',
                            min: minSlider.value,
                            max: maxSlider.value,
                            blanks: blanksCheckbox.checked
                        };
                    }
                } else if (colType === 'numeric') {
                    const minSlider = controlDiv.querySelector(`#filter-min-${colIndex}`);
                    const maxSlider = controlDiv.querySelector(`#filter-max-${colIndex}`);
                    const blanksCheckbox = controlDiv.querySelector(`#filter-${colIndex}-blank`);
                    if (minSlider && maxSlider) {
                         activeFilters[colIndex] = {
                            name: colName,
                            type: 'numeric',
                            min: parseFloat(minSlider.value),
                            max: parseFloat(maxSlider.value),
                            blanks: blanksCheckbox.checked
                        };
                    }
                } else if (colType === 'categorical') {
                    const selectedValues = new Set();
                    controlDiv.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => selectedValues.add(cb.value));
                    if (selectedValues.size > 0) {
                        activeFilters[colIndex] = {
                            name: colName,
                            type: 'categorical',
                            values: selectedValues
                        };
                    } else {
                        activeFilters[colIndex] = {
                            name: colName,
                            type: 'categorical',
                            values: new Set(['__FILTER_OUT_ALL__'])
                        };
                    }
                } else if (colType === 'boolean') {
                    const selectedRadio = controlDiv.querySelector('input[type="radio"]:checked');
                    if (selectedRadio && selectedRadio.value !== 'all') {
                        activeFilters[colIndex] = {name: colName, type: 'boolean', selection: selectedRadio.value };
                    }
                }
            });
            // Filter all map markers
            mapMarkers = [];
            originalMarkerData.forEach(item => {
                let allFiltersPass = true;
                const rowData = item.data;

                for (const colIndexStr in activeFilters) {
                    const colIndex = parseInt(colIndexStr);
                    const filter = activeFilters[colIndex];
                    let value = rowData[colIndex];

                    let filterPasses = true;

                    if (filter.type === 'date') {
                        if (value === undefined || value === null) {
                            if (!filter.blanks) {
                                filterPasses = false;
                                console.log("breaks on filter blanks")
                            };
                        } else {
                            numValue = parseInt(value.getTime())
                            console.log(filter.name, numValue)
                            console.log(filter.min, value < filter.min, formatDate(filter.min))
                            console.log(filter.max, value > filter.max, formatDate(filter.max))
                            if (value < filter.min || value > filter.max) {
                                filterPasses = false;
                                console.log("breaks on filter numbers")
                            };
                        }
                    } else if (filter.type === 'numeric') {
                        if (value === undefined || value === null) {
                            if (!filter.blanks) {
                                filterPasses = false;
                            }
                        } else {
                            const numValue = parseFloat(value);
                            if (numValue < filter.min || numValue > filter.max) {
                                filterPasses = false;
                            }
                        }
                    } else if (filter.type === 'categorical') {
                        const strValue = value?.toString().trim() || '(Blank)';
                        if (!filter.values.has(strValue)) {
                            filterPasses = false;
                        }
                    } else if (filter.type === 'boolean') {
                        const boolValue = value === true || value === 1 || value?.toString().toLowerCase() === 'true';
                        const filterSelection = filter.selection === 'true';
                        if (boolValue !== filterSelection) {
                            filterPasses = false;
                        }
                    }
                    // Break early if filter fails
                    if (!filterPasses) {
                        allFiltersPass = false
                        break;
                    }
                }

                // Add or remove marker based on all filters
                if (allFiltersPass) {
                    if (!map.hasLayer(item.marker)) {
                        item.marker.addTo(map);
                    }
                    mapMarkers.push(item.marker);
                } else {
                    if (map.hasLayer(item.marker)) {
                        map.removeLayer(item.marker);
                    }
                }
            });
            // Re-apply overlay styling to the now visible markers
            applyOverlayStyle();
        }

        function handleOverlayChange(event) {
            if (event.target.name === 'overlay-column') {
                const selectedValue = event.target.value;
                activeOverlayColumnIndex = selectedValue === 'none' ? -1 : parseInt(selectedValue);
                applyOverlayStyle();
            }
        }

        function applyOverlayStyle() {
            if (!map || originalMarkerData.length === 0) return;

            // Reset all marker styles first
            const defaultIcon = new L.Icon.Default();
            originalMarkerData.forEach(item => item.marker.setIcon(defaultIcon));
            mapLegend.classList.add('hidden');
            legendItems.innerHTML = '';

            if (activeOverlayColumnIndex === -1) {
                return;
            }

            const col = columnInfo[activeOverlayColumnIndex];
            if (!col) {
                console.warn("Selected overlay column is not found.");
                return;
            }
            if (col.type === 'date') {
                // Calculate min/max for the overlay column from the original data
                const dates = currentSheetData.slice(1)
                    .map(row => {
                        const dateValue = new Date(row[activeOverlayColumnIndex]);
                        return isNaN(dateValue) || dateValue.getTime() === 0 ? null : dateValue.getTime();
                    })
                    .filter(v => v !== null);
                if (dates.length === 0) return;

                const minTimestamp = Math.min(...dates);
                const maxTimestamp = Math.max(...dates);

                // Apply styles to *currently visible* markers
                mapMarkers.forEach(marker => {
                    // Find the original data associated with this visible marker
                    const itemData = originalMarkerData.find(item => item.marker === marker);
                    if (!itemData) return;

                    const dateValue = new Date(itemData.data[activeOverlayColumnIndex]);
                    const timestamp = dateValue.getTime();

                    if (!isNaN(timestamp)) {
                        const color = getColorForValue(timestamp, minTimestamp, maxTimestamp);
                        marker.setIcon(L.divIcon({
                            className: 'custom-marker-icon',
                            html: `<div style="background-color: ${color}; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.5); box-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>`,
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        }));
                    } else {
                        marker.setIcon(L.divIcon({
                            className: 'custom-marker-icon',
                            html: `<div style="background-color: #cccccc; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.5); box-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>`,
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        }));
                    }
                });

                // Create a date-specific legend update function
                updateDateLegend(col.header, minTimestamp, maxTimestamp);
            } else if (col.type === 'numeric') {
                // Calculate min/max for the overlay column from the original data
                const values = currentSheetData.slice(1)
                  .map(row => parseFloat(row[activeOverlayColumnIndex]))
                  .filter(v => !isNaN(v));
                if (values.length === 0) return;

                const min = Math.min(...values);
                const max = Math.max(...values);

                // Apply styles to *currently visible* markers
                mapMarkers.forEach(marker => {
                    // Find the original data associated with this visible marker
                    const itemData = originalMarkerData.find(item => item.marker === marker);
                    if (!itemData) return;

                    const value = parseFloat(itemData.data[activeOverlayColumnIndex]);
                    if (!isNaN(value)) {
                        const color = getColorForValue(value, min, max);
                        marker.setIcon(L.divIcon({
                            className: 'custom-marker-icon',
                            html: `<div style="background-color: ${color}; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.5); box-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>`,
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        }));
                    } else {
                        marker.setIcon(L.divIcon({
                           className: 'custom-marker-icon',
                           html: `<div style="background-color: #cccccc; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.5); box-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>`,
                           iconSize: [16, 16],
                           iconAnchor: [8, 8]
                        }));
                    }
                });
                updateNumericLegend(col.header, min, max);
            }
            else if (col.type === 'categorical') {
                const uniqueCategories = new Set(currentSheetData.slice(1).map(val => val[activeOverlayColumnIndex]?.toString().trim()).sort());
                if (uniqueCategories.length === 0) return;
                categories = Array.from(uniqueCategories).sort();
                const colors = generateEvenHexColors(categories);
                // Apply styles to *currently visible* markers
                mapMarkers.forEach(marker => {
                    // Find the original data associated with this visible marker
                    const itemData = originalMarkerData.find(item => item.marker === marker);
                    const color = colors[itemData.data[activeOverlayColumnIndex]]
                    if (color) {
                        marker.setIcon(L.divIcon({
                            className: 'custom-marker-icon',
                            html: `<div style="background-color: ${color}; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.5); box-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>`,
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        }));
                    } else {
                         // Style for null/invalid values in overlay column
                         marker.setIcon(L.divIcon({
                            className: 'custom-marker-icon',
                            html: `<div style="background-color: #cccccc; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.5); box-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>`,
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                         }));
                    }
                });
                updateCategoricalLegend(col.header, categories, colors)
            }
            // Show legend
            mapLegend.classList.remove('hidden');
        }
        function updateDateLegend(title, min, max) {
            legendItems.innerHTML = '';
            mapLegend.querySelector('h4').textContent = `Legend: ${title}`;

            // Create 5 steps for the legend
            const steps = 5;
            for (let i = 0; i < steps; i++) {
                const value = min + (max - min) * (i / (steps - 1));
                const color = getColorForValue(value, min, max);

                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = color;
                const label = document.createElement('span');
                // Show range or single value depending on step
                if (i < steps - 1) {
                    const nextValue = min + (max - min) * ((i + 1) / (steps - 1));
                    label.textContent = `${formatDate(value)} - ${formatDate(nextValue)}`;
                } else {
                     label.textContent = `≥ ${formatDate(value)}`;
                }
                // For the first item, adjust label
                if (i === 0 && steps > 1) {
                     label.textContent = `≤ ${formatDate(value)}`;
                }

                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                legendItems.appendChild(legendItem);
            }
        }
        function updateNumericLegend(title, min, max) {
            legendItems.innerHTML = '';
            mapLegend.querySelector('h4').textContent = `Legend: ${title}`;

            // Create 5 steps for the legend
            const steps = 5;
            for (let i = 0; i < steps; i++) {
                const value = min + (max - min) * (i / (steps - 1));
                const color = getColorForValue(value, min, max);

                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = color;
                const label = document.createElement('span');
                // Show range or single value depending on step
                if (i < steps - 1) {
                    const nextValue = min + (max - min) * ((i + 1) / (steps - 1));
                    label.textContent = `${value.toFixed(1)} - ${nextValue.toFixed(1)}`;
                } else {
                     label.textContent = `≥ ${value.toFixed(1)}`;
                }
                // For the first item, adjust label
                if (i === 0 && steps > 1) {
                     label.textContent = `≤ ${value.toFixed(1)}`;
                }

                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                legendItems.appendChild(legendItem);
            }
        }
        function updateCategoricalLegend(title, categories, colors) {
            legendItems.innerHTML = '';
            mapLegend.querySelector('h4').textContent = `Legend: ${title}`;
            for (const category of categories) {
                const color = colors[category];
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = color;
                const label = document.createElement('span');
                label.textContent = category;
                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                legendItems.appendChild(legendItem);
            }
        }
        // Hide legend
        hideLegend.addEventListener('click', () => {mapLegend.classList.add('hidden')});

        // --- Helper Functions ---
        function detectColumnType(columnHeader, columnData) {
            if (!columnHeader) return 'no-header';

            // Check if column appears to be an identifier or reference column
            const identifierKeywords = ['id', 'uuid', 'key', 'code', 'reference'];
            const identifierCheck = (name) => identifierKeywords.some(keyword => name.toLowerCase().includes(keyword));
            if (identifierCheck(columnHeader)) return 'identifier';

            // Check if column is empty
            const validData = columnData.filter(val => val !== null && val !== undefined && val !== '');
            if (validData.length === 0) return 'null-column';

            const values = columnData.map(val => val === null || val === undefined ? undefined : val.toString().trim());
            const uniqueValues = new Set(values);
            const uniquenessRatio = uniqueValues.size / columnData.length;

            // Boolean check (only 'true/false/0/1' case-insensitive)
            const booleanCheck = validData.every(val => {
                const lowerVal = val.toString().toLowerCase();
                return ['true', 'false', '1', '0'].includes(lowerVal);
            });
            if (booleanCheck && uniqueValues.size <= 2) return 'boolean';

            // Check if values look like dates
            const dateCheck = validData.every(val =>
                (typeof val === 'object' && val instanceof Date && !isNaN(val.getTime())) ||
                (typeof val === 'string' && (val.includes('/') || val.includes('-')) && new Date(val).toString() !== 'Invalid Date')
            );
            if (dateCheck && uniqueValues.size < 100) return 'date';

            // Numeric check
            const numericCheck = validData.every(val => !isNaN(parseFloat(val)) && isFinite(val));
            // Categorical check (relatively few unique string values)
            if (!numericCheck && (uniqueValues.size <= 25 && uniquenessRatio < 0.5)) {return 'categorical'}
            // Categorical check with tighter restrictions
            else if (!numericCheck && (uniqueValues.size <= 5)) {return 'categorical'}
            // Text/Unique Text (many unique string values)
            else if (!numericCheck && uniquenessRatio > 0.8) {return 'text-unique'}
            // Numeric columns
            else if (numericCheck) {return 'numeric'}

            return 'text';
        }
        function getColorForValue(value, min, max) {
            if (max === min) return 'rgb(180, 180, 180)';
            const normalized = Math.max(0, Math.min(1, (value - min) / (max - min)));
             // Simple Blue (low) to Red (high) gradient
            const r = Math.round(255 * normalized);
            const g = 0; // Or Math.round(255 * (1 - Math.abs(normalized - 0.5) * 2)); for Green in middle
            const b = Math.round(255 * (1 - normalized));

            return `rgb(${r}, ${g}, ${b})`;
        }
        function generateEvenHexColors(categories) {
            const uniqueSorted = [...new Set(categories)].sort();
            const count = uniqueSorted.length;
            const colors = {};

            uniqueSorted.forEach((category, i) => {
                if (category === undefined) {
                    colors[category] = '#cccccc'
                } else {
                    const hue = Math.round((360 / count) * i);
                    const saturation = 70;
                    const lightness = 55;
                    colors[category] = hslToHex(hue, saturation, lightness);
                }
            });
            return colors;
        }
        function hslToHex(h, s, l) {
            s /= 100;
            l /= 100;

            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c/2;
            let r = 0, g = 0, b = 0;

            if (0 <= h && h < 60) [r, g, b] = [c, x, 0];
            else if (60 <= h && h < 120) [r, g, b] = [x, c, 0];
            else if (120 <= h && h < 180) [r, g, b] = [0, c, x];
            else if (180 <= h && h < 240) [r, g, b] = [0, x, c];
            else if (240 <= h && h < 300) [r, g, b] = [x, 0, c];
            else if (300 <= h && h < 360) [r, g, b] = [c, 0, x];

            const toHex = (v) => {
                const hex = Math.round((v + m) * 255).toString(16).padStart(2, '0');
                return hex;
            };

            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        // Helper to stringify anything
        function stringify(data) {
          try {
            return typeof data === 'object' ? JSON.stringify(data) : String(data);
          } catch (e) {
            return '[Unserializable Object]';
          }
        }
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        // --- Logging ---
        let logs = [];

        ['log', 'warn', 'error', 'info'].forEach(level => {
          const original = console[level].bind(console);
          console[level] = (...args) => {
            logs.push(`[console.${level}] ${args.map(stringify).join(' ')}`);
            logBtn.disabled = false;
            original(...args);
          };
        });
        // Add network requests to log
        const originalFetch = window.fetch;
        window.fetch = async (...args) => {
          try {
            const response = await originalFetch(...args);
            if (!response.ok) {
              logs.push(`[fetch] ${args[0]} -> ${response.status} ${response.statusText}`);
            }
            return response;
          } catch (error) {
            logs.push(`[fetch] ${args[0]} -> NETWORK ERROR: ${error.message}`);
            throw error;
          }
        };
        const originalOpen = XMLHttpRequest.prototype.open;
        const originalSend = XMLHttpRequest.prototype.send;

        XMLHttpRequest.prototype.open = function (method, url, ...rest) {
          this._requestUrl = url;
          this._requestMethod = method;
          return originalOpen.call(this, method, url, ...rest);
        };

        XMLHttpRequest.prototype.send = function (...args) {
          this.addEventListener('loadend', function () {
            if (this.status >= 400) {
              logs.push(`[XHR] ${this._requestMethod} ${this._requestUrl} -> ${this.status} ${this.statusText}`);
            }
          });
          return originalSend.apply(this, args);
        };
        logBtn.addEventListener('click', () => {
            const blob = new Blob([logs.join('\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'console-log.txt';
            a.click();
            URL.revokeObjectURL(url);
        });
    });
</script>
</html>